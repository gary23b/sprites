// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	image "image"

	models "github.com/gary23b/sprites/models"
	mock "github.com/stretchr/testify/mock"
)

// Scratch is an autogenerated mock type for the Scratch type
type Scratch struct {
	mock.Mock
}

// AddCostume provides a mock function with given fields: img, name
func (_m *Scratch) AddCostume(img image.Image, name string) {
	_m.Called(img, name)
}

// AddSound provides a mock function with given fields: path, name
func (_m *Scratch) AddSound(path string, name string) {
	_m.Called(path, name)
}

// AddSprite provides a mock function with given fields: UniqueName
func (_m *Scratch) AddSprite(UniqueName string) models.Sprite {
	ret := _m.Called(UniqueName)

	var r0 models.Sprite
	if rf, ok := ret.Get(0).(func(string) models.Sprite); ok {
		r0 = rf(UniqueName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(models.Sprite)
		}
	}

	return r0
}

// DeleteAllSprites provides a mock function with given fields:
func (_m *Scratch) DeleteAllSprites() {
	_m.Called()
}

// DeleteSprite provides a mock function with given fields: _a0
func (_m *Scratch) DeleteSprite(_a0 models.Sprite) {
	_m.Called(_a0)
}

// Exit provides a mock function with given fields:
func (_m *Scratch) Exit() {
	_m.Called()
}

// GetHeight provides a mock function with given fields:
func (_m *Scratch) GetHeight() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetScreenshot provides a mock function with given fields:
func (_m *Scratch) GetScreenshot() image.Image {
	ret := _m.Called()

	var r0 image.Image
	if rf, ok := ret.Get(0).(func() image.Image); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(image.Image)
		}
	}

	return r0
}

// GetSpriteID provides a mock function with given fields: UniqueName
func (_m *Scratch) GetSpriteID(UniqueName string) int {
	ret := _m.Called(UniqueName)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(UniqueName)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetSpriteInfo provides a mock function with given fields: UniqueName
func (_m *Scratch) GetSpriteInfo(UniqueName string) models.SpriteState {
	ret := _m.Called(UniqueName)

	var r0 models.SpriteState
	if rf, ok := ret.Get(0).(func(string) models.SpriteState); ok {
		r0 = rf(UniqueName)
	} else {
		r0 = ret.Get(0).(models.SpriteState)
	}

	return r0
}

// GetSpriteInfoByID provides a mock function with given fields: id
func (_m *Scratch) GetSpriteInfoByID(id int) models.SpriteState {
	ret := _m.Called(id)

	var r0 models.SpriteState
	if rf, ok := ret.Get(0).(func(int) models.SpriteState); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.SpriteState)
	}

	return r0
}

// GetWidth provides a mock function with given fields:
func (_m *Scratch) GetWidth() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// PlaySound provides a mock function with given fields: name, volume
func (_m *Scratch) PlaySound(name string, volume float64) {
	_m.Called(name, volume)
}

// PressedUserInput provides a mock function with given fields:
func (_m *Scratch) PressedUserInput() *models.UserInput {
	ret := _m.Called()

	var r0 *models.UserInput
	if rf, ok := ret.Get(0).(func() *models.UserInput); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.UserInput)
		}
	}

	return r0
}

// SendMsg provides a mock function with given fields: toSpriteID, msg
func (_m *Scratch) SendMsg(toSpriteID int, msg interface{}) {
	_m.Called(toSpriteID, msg)
}

// SpriteUpdateFull provides a mock function with given fields: in
func (_m *Scratch) SpriteUpdateFull(in models.Sprite) {
	_m.Called(in)
}

// SpriteUpdatePosAngle provides a mock function with given fields: in
func (_m *Scratch) SpriteUpdatePosAngle(in models.Sprite) {
	_m.Called(in)
}

// SubscribeToJustPressedUserInput provides a mock function with given fields:
func (_m *Scratch) SubscribeToJustPressedUserInput() chan *models.UserInput {
	ret := _m.Called()

	var r0 chan *models.UserInput
	if rf, ok := ret.Get(0).(func() chan *models.UserInput); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan *models.UserInput)
		}
	}

	return r0
}

// UnSubscribeToJustPressedUserInput provides a mock function with given fields: in
func (_m *Scratch) UnSubscribeToJustPressedUserInput(in chan *models.UserInput) {
	_m.Called(in)
}

// WhoIsNearMe provides a mock function with given fields: x, y, distance
func (_m *Scratch) WhoIsNearMe(x float64, y float64, distance float64) []models.NearMeInfo {
	ret := _m.Called(x, y, distance)

	var r0 []models.NearMeInfo
	if rf, ok := ret.Get(0).(func(float64, float64, float64) []models.NearMeInfo); ok {
		r0 = rf(x, y, distance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.NearMeInfo)
		}
	}

	return r0
}

// NewScratch creates a new instance of Scratch. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewScratch(t interface {
	mock.TestingT
	Cleanup(func())
}) *Scratch {
	mock := &Scratch{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
